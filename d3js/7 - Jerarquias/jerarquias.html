<!DOCTYPE html>
<html lang="es">
<head>
    <title>D3.js - Jerarquias</title>
    <meta charset="utf-8"/>
    <!--	d3 😍-->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <!--nuestro estilo -->
    <link type="text/css" rel="stylesheet" href="style.css"/>

    <link href="https://fonts.googleapis.com/css?family=Poppins" rel="stylesheet">
</head>
<body>
<div id="viz">
    <svg></svg>
</div>
<script>

    //leemos un json
    d3.json("tweets.json")
        .then(function (data) {
            viz(data)
        })

    //def viz
    function viz(data) {

        const coloresScale = d3.scaleOrdinal()
            .range(["#5EAFC6", "#FE9922", "#93c464", "#75739F"]);

        //necesitamos tener data ordenada de manera jerarquica
        //https://github.com/d3/d3-hierarchy/blob/master/README.md#hierarchy

        //https://github.com/d3/d3-array/blob/master/README.md#group
        //agruparemos por usuario, notar que por defecto nos genera un Map, pero nosotros queremos un array de objetos
        const nestedTweets =
            Array.from(d3.group(data.tweets, d => d.user), ([key, value]) => ({key, value}))

        console.log("nestedTweets:");
        console.log(JSON.stringify(nestedTweets));

        //necesitamos que haya un padre
        var packableTweets = {id: "All Tweets", value: nestedTweets};
        console.log("packableTweets:");
        console.log(packableTweets);

        //teniendo la data de manera jerarquica, hacemos que nos genere los relaciones
        //https://github.com/d3/d3-hierarchy#hierarchy
            var root = d3.hierarchy(packableTweets, d => d.value);

        console.log("root:");
        console.log(root);

        //https://github.com/d3/d3-hierarchy/blob/master/README.md#tree
        //vamos a hacer un arbol
        var treeChart = d3.tree();

        //tamaño desde el centro
        treeChart.size([200, 200]);
        // treeChart.size([500, 500]);

        //generamos la data necesaria
        var treeData = treeChart(root).descendants();
        console.log("treeData:");
        console.log(treeData);
        console.log(treeData.filter(d => d.parent));

        //creamos grupos, dentro de cada grupo pondremos los elementos
        d3.select("svg")
            .append("g")
            .attr("id", "treeG")
            .attr("transform", "translate(300,300)")
            // .attr("transform", "translate(60,20)")
            .selectAll("g")
            .data(treeData).enter()
            .append("g")
            .attr("class", "node")
            .attr("transform", function (d) {
                // console.log(d.x)
                // console.log(d.y)
                // return 'translate(' + d.x + ',' + d.y + ')'
                // return 'translate(' + d.y + ',' + d.x + ')'
                return 'translate(' + project(d.x, d.y)[0] + ',' + project(d.x, d.y)[1] + ')'
            });

        //circulos de los nodos
        d3.selectAll("g.node")
            .append("circle")
            .attr("r", 10)
            .style("fill", d => coloresScale(d.depth))
            .style("stroke", "white")
            .style("stroke-width", "2px");

        //texto
        //notar el texto que se muestra
        var nodo = d3.selectAll("g.node");
        nodo.append("text")
            .style("text-anchor", "middle")
            .style("fill", "#4f442b")
            .text(d => d.data.id || d.data.key || d.data.content);

        nodo.append("rect")
            .attr("width", function (d, i) {

                console.log(d3.selectAll("text").nodes()[i].getBBox().x);
                return d3.selectAll("text").nodes()[i].getBBox().width;
            })
            .attr("height", 20)
            .attr("x", (d, i) => d3.selectAll("text").nodes()[i].getBBox().x)
            .attr("y", (d, i) => d3.selectAll("text").nodes()[i].getBBox().y)
            .style("fill", "white")
            .style("opacity", "0.5");
        d3.selectAll("text").remove()
        //
        nodo.append("text")
            .style("text-anchor", "middle")
            .style("fill", "#4f442b")
            .text(function (d) {
                console.log(d.data)
                return d.data.key || d.data.id || d.data.content
            });

        // d3.select("#treeG").selectAll("line")
        //     .data(treeData.filter(d => d.parent))
        //     .enter().insert("line", "g")
        //     .attr("x1", d => d.parent.x)
        //     .attr("y1", d => d.parent.y)
        //     .attr("x2", d => d.x)
        //     .attr("y2", d => d.y)
        //     .style("stroke", "black");

        // d3.select("#treeG").selectAll("line")
        //     .data(treeData.filter(d => d.parent))
        //     .enter().insert("line", "g")
        //     .attr("x1", d => d.parent.y)
        //     .attr("y1", d => d.parent.x)
        //     .attr("x2", d => d.y)
        //     .attr("y2", d => d.x)
        //     .style("stroke", "black");

        d3.select("#treeG").selectAll("line")
            .data(treeData.filter(d => d.parent))
            .enter().insert("line", "g")
            .attr("x1", d => project(d.parent.x, d.parent.y)[0])
            .attr("y1", d => project(d.parent.x, d.parent.y)[1])
            .attr("x2", d => project(d.x, d.y)[0])
            .attr("y2", d => project(d.x, d.y)[1])
            .style("stroke", "black");

        function project(x, y) {
            var angle = x / 90 * Math.PI;
            var radius = y;
            return [radius * Math.cos(angle), radius * Math.sin(angle)];
        }
    }
</script>
</body>
</html>